# Labeling Instruction

You need to decide whether a given summary of a function satisfies a given list of properties.
The summary is generated by a Language Model (LLM), which utilizes function code along with a concise, relevant context - specifically, a list of callees' text descriptions.

For each task you will be provided with three entities: a function code (referred to subsequently as (I)), a summary (II), and a list of callees' descriptions (III) that have been given to LLM.

## How to do the task
Open your preferred IDE. Navigate to *the function* (I) you see in the current task.
Read the source code to understand what it actually does. If needed, explore dependencies - declarations of global variables, structures, functions that are used in the function code (use IDE actions for this purpose).
Then examine provided summary (II) and provided callees descriptions (III).
The essence of the task is to check whether this summary (II) satisfies 
**Sufficiency**, **Verbosity**, **Triviality**, **Factuality** properties and whether it contains **Hallucinations** and **Random Facts**.

Below are definitions and descriptions of the properties in question.

We call a summary (II) **Sufficient** if it satisfies all the following properties:
1. It contains enough information to understand what *the function* (I) actually does without looking at the function body.
2. Implementation details are included if they are crucial for correct usage of the function (I). 
_For example, if there are functions doing pretty much the same in one repository, but one with and one without multithreading - this implementation difference should be included to identify one from another._

We call a summary (II) **Verbose** if it satisfies at least one of the following properties:
1. It contains redundant information or an overly detailed description, e.g. a description of local variables.
2. It explains *the function* (I) statement by statement in a separate manner, e.g. "calling function 'foo' with arguments 'x'".
3. It contains repeated information.

We call a summary (II) **Trivial** if it satisfies the following property:
1. All the information given in the summary can be deduced from the function (I) signature: name, argument names and types, return type.

We call a summary (II) **Factual** if it satisfies the following properties:
1. It does not include any facts or details that can be proven wrong based on the info given to LLM. For example "if x > 0, function returns true", when the real condition is "x < 0".

We say that a summary (II) contains **Hallucinations** if it satisfies the following property:
1. It delivers a piece of information that cannot be inferred from the repository or general knowledge. In other words, a piece of information that might be considered fictional/imaginary. Instances of this behavior include, but are not limited to:
   - Mentioning non-existing code entities: variables, functions, structures, etc.
   - Mentioning any invariants or guarantees that can't be inferred from the info given to LLM, e.g. thread-safety, time/memory complexity, etc.
   - Additional claims about implicit behaviors, usages or meta-knowledge, that are too specific to be considered a reasonable inference from (I) and (III). For example, stating that `normalize_frame()` function is called for **each** frame of a video while having no context about its usage at all.

We say that a summary (II) contains **Random Facts** if it satisfies the following property:
1. It includes a claim that offers no help in understanding the code whatsoever, and seems out of place. 
For example, a random statement such as  *"C is a popular yet complicated language"* inserted in a middle of a summary (II).

<div style="page-break-after: always"></div>

## Examples
### **Sufficiency**:

#### Example 1
```c
// port is locked and interrupts are disabled
// uart_start( ) calls us under the port spinlock irqsave
static void arc_serial_start_tx(struct uart_port *port)
{
  arc_serial_tx_chars(port);
}
```
Here Sufficiency should be set to `False`: what the function actually does is unclear from this summary alone.

#### Example 2
```c
// Update the prev pointer of the next agino.
// Returns -ENOLINK if the inode is not in cache.
static int xfs_iunlink_update_backref(struct xfs_perag *pag,
                                      xfs_agino_t prev_agino,
                                      xfs_agino_t next_agino)
{
    struct xfs_inode *ip;

    /* No update necessary if we are at the end of the list. */
    if (next_agino == NULLAGINO)
        return 0;

    ip = xfs_iunlink_lookup(pag, next_agino);
    if (!ip)
        return -ENOLINK;

    ip->i_prev_unlinked = prev_agino;
    return 0;
}
```
Here Sufficiency should be set to `True`.

<div style="page-break-after: always"></div>

### **Verbosity**:

#### Example 1
```
// This function reads the header of an AIFF file and extracts the necessary information to initialize the audio decoder.
// It returns the number of frames in the file.
// 
// Here's a summary of the function's main steps:
// 
// 1. It reads the AIFF header, which includes the file format version, the number of channels, the sample rate, and the number of frames.
// 2. It checks that the file format version is valid and that the number of channels, sample rate, and number of frames are valid.
// 3. It sets the codec ID based on the number of bits per sample and the file format version.
// 4. It computes the block duration and bit rate based on the sample rate, number of channels, and codec ID.
// 5. It skips over any remaining data in the header.
// 
// The function returns the number of frames in the file.
static int get_aiff_header(AVFormatContext *s, int64_t size,
                                    unsigned version)
{
  ...
}
```
Here Verbosity should be set to `True` because this summary explains implementation details separately, statement by statement - `it reads...`, `it checks...`.

<div style="page-break-after: always"></div>

### **Triviality**:

#### Example 1
```
// Build a CHK2 or CMP2 instruction.
static void build_chk2_cmp2(m68k_info *info, int size) {
  cs_m68k_op *op0;
  cs_m68k_op *op1;
  cs_m68k *ext = build_init_op(info, M68K_INS_CHK2, 2, size);
  uint32_t extension = read_imm_16(info);
  if (BIT_B(extension))
    MCInst_setOpcode(info->inst, M68K_INS_CHK2);
  else
    MCInst_setOpcode(info->inst, M68K_INS_CMP2);
  op0 = &ext->operands[0];
  op1 = &ext->operands[1];
  get_ea_mode_op(info, op0, info->ir, size);
  op1->address_mode = M68K_AM_NONE;
  op1->type = M68K_OP_REG;
  op1->reg = (BIT_F(extension) ? M68K_REG_A0 : M68K_REG_D0) + ((extension >> 12) & 7);
}
```
Here Triviality should be set to `True` because the meaning of this summary follows directly from the function name.

<div style="page-break-after: always"></div>

### **Hallucinations**:

#### Example 1
```
// Returns True if this string contains the given string.
// This is an O(n) operation, where "n" is the length of the given string.
bool contains(StringRef Other) const { return find(Other) != npos; }
```
In this instance Hallucinations is set to `True` because the LLM have not seen implementation details of the `find()` function, and therefore cannot know its time complexity.
Factual is also set to `True`, because the only mistake is already classified as a hallucination.

#### Example 2
```
// Print a packet to the log.
// If avcl is not NULL, print to avcl->logctx, otherwise print to av_log.
void av_pkt_dump_log2(void *avcl, int level, const AVPacket *pkt, int dump_payload,
                      const AVStream *st)
{
    pkt_dump_internal(avcl, NULL, level, pkt, dump_payload, st->time_base);
}
```
Here Hallucinations is set to `True` because `avcl->logctx` expression is not present in the code (I) or callees' descriptions (III). Therefore `logctx` field is considered to be a hallucination.
Factual is also set to `True`, because other facts mentioned in the docstring are correct.

<div style="page-break-after: always"></div>

### **Factuality**:

#### Example 1
```
// This function reads the header of an AIFF file and extracts the necessary information to initialize the audio decoder.
// It returns the number of frames in the file.
// 
// Here's a summary of the function's main steps:
// 
// 1. It reads the AIFF header, which includes the file format version, the number of channels, the sample rate, and the number of frames.
// 2. It checks that the file format version is valid and that the number of channels, sample rate, and number of frames are valid.
// 3. It sets the codec ID based on the number of bits per sample and the file format version.
// 4. It computes the block duration and bit rate based on the sample rate, number of channels, and codec ID.
// 5. It skips over any remaining data in the header.
// 
// The function returns the number of frames in the file.
static int get_aiff_header(AVFormatContext *s, int64_t size,
                                    unsigned version)
{
    AVIOContext *pb        = s->pb;
    AVCodecParameters *par = s->streams[0]->codecpar;
    AIFFInputContext *aiff = s->priv_data;
    int exp;
    uint64_t val;
    int sample_rate;
    unsigned int num_frames;
    int channels;

    if (size & 1)
        size++;
    par->codec_type = AVMEDIA_TYPE_AUDIO;
    channels = avio_rb16(pb);
    par->ch_layout.nb_channels = channels;
    num_frames = avio_rb32(pb);
    par->bits_per_coded_sample = avio_rb16(pb);

    exp = avio_rb16(pb) - 16383 - 63;
    val = avio_rb64(pb);
    if (exp <-63 || exp >63) {
        av_log(s, AV_LOG_ERROR, "exp %d is out of range\n", exp);
        return AVERROR_INVALIDDATA;
    }
    if (exp >= 0)
        sample_rate = val << exp;
    else
        sample_rate = (val + (1ULL<<(-exp-1))) >> -exp;
    if (sample_rate <= 0)
        return AVERROR_INVALIDDATA;

    par->sample_rate = sample_rate;
    if (size < 18)
        return AVERROR_INVALIDDATA;
    size -= 18;

    /* get codec id for AIFF-C */
    if (size < 4) {
        version = AIFF;
    } else if (version == AIFF_C_VERSION1) {
        par->codec_tag = avio_rl32(pb);
        par->codec_id  = ff_codec_get_id(ff_codec_aiff_tags, par->codec_tag);
        if (par->codec_id == AV_CODEC_ID_NONE)
            avpriv_request_sample(s, "unknown or unsupported codec tag: %s",
                                  av_fourcc2str(par->codec_tag));
        size -= 4;
    }
    ...
}
```
Here Factuality is set to `False` because of this statement:
`It checks that the file format version is valid and that the number of channels, sample rate, and number of frames are valid.`
But in fact this code doesn't check the validity of number of channels in any way.
